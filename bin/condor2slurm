#!/usr/bin/env python
"""
    %prog [options] file1 file2 ....

convert the jobs in the specified condor files to lsf jobs, each in their own
file

the condor file should be similar to this (extra stuff can exist)

Executable = /some/path

+job_name = "some name"
Arguments = "some args"

+job_name = "some name"
Arguments = "some args"

etc.

The file will be the same as the job name with spaces replaced by dashes
"""

from __future__ import print_function
import os


def get_args():
    from argparse import ArgumentParser

    parser = ArgumentParser()

    parser.add_argument('--flist', nargs='+', required=True)
    parser.add_argument(
        "--outdir",
        help=(
            "write in specified directory, "
            "default is same dir as condor file"
        ),
    )

    parser.add_argument("--ncores", "-n", type=int, default=1,
                        help="number of cores to use")

    parser.add_argument(
        "--extra-commands",
        default="",
        help=("extra shell comments to run, e.g. source a file"),
    )

    parser.add_argument("--walltime", default="24:00:00",
                        help=("walltime, default 24:00:00"))

    return parser.parse_args()


def process_file(fname):

    exec_found = False
    job_names = []
    args_list = []

    with open(fname) as fobj:

        for line in fobj:
            line = line.strip()

            if line[0:10].lower() == "executable":
                exec_found = True
                exec_file = line.split("=")[1].strip()
            else:
                if line[0:9].lower() == "+job_name":
                    job_name = line.split("=")[1].strip()
                    job_name = (
                        job_name.replace(
                            '"', ""
                        ).replace(
                            "'", ""
                        ).replace(
                            " ", "-"
                        )
                    )
                    job_names.append(job_name)

                if line[0:9].lower() == "arguments":
                    args = line.split("=")[1].strip()
                    args_list.append(args)

    if not exec_found:
        raise ValueError("no line with executable = ")

    if len(job_names) != len(args_list):
        raise ValueError(
            "found %d job_names but %d args" % (len(job_names), len(args_list))
        )

    return exec_file, job_names, args_list


SLURM_TEMPLATE = r'''#!/bin/bash
# Name of the job
#SBATCH --job-name=%(job_name)s

# Number of compute nodes
#SBATCH --nodes=1

# Number of cores, in this case one
#SBATCH --ntasks-per-node=%(ncores)d

# Walltime (job duration)
#SBATCH --time=%(walltime)s

# memory
#SBATCH --mem=%(mem)s

#SBATCH --partition=milano
#SBATCH --account=rubin:default

%(extra_commands)s
%(exec_file)s %(args)s
'''


def write_jobs(
    exec_file, job_names, args_list, outdir, extra_commands, ncores,
    walltime
):

    outdir = os.path.abspath(outdir)

    if not os.path.exists(outdir):
        os.makedirs(outdir)

    njob = len(job_names)
    i = 0
    for job_name, args in zip(job_names, args_list):
        fname = "%s.lsf" % job_name
        fname = os.path.join(outdir, fname)

        if (i % 1000) == 0:
            print("%d/%d" % (i + 1, njob), job_name, fname)
            print(args)
            print()

        wqtext = SLURM_TEMPLATE % dict(
            exec_file=exec_file,
            args=args,
            job_name=job_name,
            extra_commands=extra_commands,
            walltime=walltime,
            ncores=ncores,
        )

        with open(fname, "w") as fobj:
            fobj.write(wqtext)

        i += 1


def main():

    args = get_args()

    for fname in args.flist:
        exec_file, job_names, args_list = process_file(fname)

        if args.outdir is None:
            outdir = os.path.dirname(fname)
        else:
            outdir = args.outdir

        write_jobs(
            exec_file=exec_file,
            job_names=job_names,
            args_list=args_list,
            outdir=outdir,
            extra_commands=args.extra_commands,
            ncores=args.ncores,
            walltime=args.walltime,
        )


if __name__ == "__main__":
    main()
