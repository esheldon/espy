#!/usr/bin/env python
import socket
import sys
import yaml
import os
import time
import datetime
import argparse
import random
import esutil as eu
import wq

pars = {
    'host': wq.DEFAULT_HOST,  # Symbolic name meaning all available interfaces
    'port': wq.DEFAULT_PORT,
    'max_buffsize': wq.DEFAULT_MAX_BUFFSIZE,
}


def get_args():

    parser = argparse.ArgumentParser()
    parser.add_argument('flist', nargs='+')

    parser.add_argument('-F', '--isfile', action='store_true',
                        help=('the argument is a file holding a list '
                              'rather than a list of files'))

    parser.add_argument('-p', '--port',
                        type=int, help='port for socket')
    parser.add_argument('--poll', type=int, default=30,
                        help=('time between polls of wq status when '
                              'we are at max allowed obs'))

    parser.add_argument('-r', '--req', default=None,
                        help='over-ride requirements')

    parser.add_argument('-n', '--njobs',
                        type=int, default=1000,
                        help='max number of jobs')

    parser.add_argument('-s', '--sleep-time', default=.2,
                        type=float,
                        help=('minimum time to sleep between individual '
                              'submisions.'))

    parser.add_argument('-f', '--force', action='store_true',
                        help=('force starting of all jobs, even if '
                              'a log file is present.'))

    parser.add_argument('-d', '--dryrun', action='store_true',
                        help='dry run.  Just print number of jobs and exit.')

    parser.add_argument('--rand', action='store_true',
                        help='randomize the order of files')

    return parser.parse_args()


def yaml_load(obj):
    return yaml.load(obj, Loader=yaml.SafeLoader)


def socket_connect(sock, conninfo, crash_on_timeout=False):
    # crash will only happen if timeouts have been enabled, otherwise we just
    # wait
    if crash_on_timeout:
        sock.connect(conninfo)
    else:
        while True:
            try:
                sock.connect(conninfo)
                break
            except socket.timeout:
                pass


def send_message(message, timeout=None, crash_on_timeout=False):
    if len(message) == 0:
        raise ValueError("message must have len > 0")

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # make sure to set timeout *before* calling connect()
    if timeout is not None:
        sock.settimeout(timeout)

    conninfo = (pars['host'], pars['port'])
    socket_connect(sock, conninfo, crash_on_timeout=crash_on_timeout)

    rdict = None
    try:
        jmess = yaml.dump(message)

        wq.server.socket_send(sock, jmess)
        data = wq.server.socket_recieve(sock, pars['max_buffsize'])

        sock.close()

        try:
            rdict = yaml_load(data)
        except:
            print('YAML err:')
            print(data)
            sys.exit(1)

        if 'error' in rdict:
            raise RuntimeError("Error reported by server: %s" % rdict['error'])

        if 'response' not in rdict:
            raise RuntimeError("Internal error. Expected a response")

    except:
        es = sys.exc_info()
        print('caught exception type:', es[0], 'details:', es[1])
        rdict = None
    finally:
        sock.close()

    if rdict is None:
        sys.exit(1)

    return rdict


class JobLister(dict):
    """
    usage: wq ls [args]

    print the job list to stdout.

    If -u/--user is sent, the listing is restricted to that user/users.

    If -f/--full is sent, the full job listing is given.  This is a yaml
    document that can be read and processed to provide a customised listing.
    """

    def __init__(self, user):
        self.user = user
        self.execute()

    def execute(self):
        message = {}
        message['command'] = 'ls'
        while True:
            try:
                resp = send_message(message)

                if resp is not None and resp['response'] is not None:
                    break
                else:
                    print("error listing jobs, trying again after 30 seconds")
                    time.sleep(30)
            except:
                print("error listing jobs, trying again after 30 seconds")
                time.sleep(30)

        self.jobs = [r for r in resp['response']
                     if ('user' in r and r['user'] == self.user)]
        self.njobs = len(self.jobs)


def get_njobs(user):
    lister = JobLister(user)
    return lister.njobs


def get_diffjobs(user, maxjobs):
    njobs = get_njobs(user)
    diffjobs = maxjobs - njobs
    return diffjobs, njobs


def get_log_fname(fname):
    return fname+'.wqlog'


def get_req(args):
    if args.req:
        req = """ -r "%s" """ % args.req
    else:
        req = ""

    return req


def submit_job(job_fname, req):
    """
    Put the job in the background

    Use os.system because it disconnects from
    the python script
    """

    dirname, fname_local = os.path.split(job_fname)

    if dirname != '':
        ds = eu.ostools.DirStack()
        ds.push(dirname)

    log_local = get_log_fname(fname_local)

    command = """
        nohup wq -p "{port}" sub {req} "{jobf}" 2>&1 > "{logf}" &
    """.format(
        port=pars['port'],
        jobf=fname_local,
        logf=log_local,
        req=req,
    )
    os.system(command)

    if dirname != '':
        ds.pop()


def submit_jobs(flist, num, total, req, sleep_time):

    for i in range(num):
        if len(flist) == 0:
            break

        nleft = len(flist)

        fname = flist.pop()

        date = datetime.datetime.now().strftime('%H:%M:%S')

        thisnum = total-nleft+1
        perc = 100.*thisnum/float(total)
        tup = (fname, date, thisnum, total, perc)

        print("    submitting %s %s %s/%s (%i%%)" % tup)
        submit_job(fname, req)

        time.sleep(sleep_time)


def go(flist, args):

    nfiles = len(flist)

    maxjobs = args.njobs
    polltime = args.poll
    sleep_time = args.sleep_time

    req = get_req(args)
    if args.rand:
        random.shuffle(flist)
    else:
        # we reverse since we will treat like a stack
        flist = list(reversed(flist))

    user = os.environ['USER']

    print("submitting jobs for user: %s" % user)
    print("number in list:           %s" % len(flist))
    print("will limit to maxjobs:    %s" % maxjobs)

    if args.dryrun:
        return

    diffjobs, njobs = get_diffjobs(user, maxjobs)

    while len(flist) > 0:

        while diffjobs <= 0:
            time.sleep(polltime)
            diffjobs, njobs = get_diffjobs(user, maxjobs)

        print("Found %s jobs diffjobs: %s" % (njobs, diffjobs))

        submit_jobs(flist, diffjobs, nfiles, req, sleep_time)

        # we set diffjobs to zero so we will sleep for the poll time before
        # checking again
        diffjobs = 0


def remove_submitted(flist):
    print('trimming to unsubmitted jobs...', end='')
    trimmed_flist = []
    for f in flist:
        logf = get_log_fname(f)
        if not os.path.exists(logf):
            trimmed_flist.append(f)
    print('kept %d/%d' % (len(trimmed_flist), len(flist)))
    return trimmed_flist


def main():
    """
    Just to provide a clean exit when we get keyboard interrupts
    """

    try:
        args = get_args()
        flist = args.flist

        if args.isfile:
            fname = flist[0]
            with open(fname) as fobj:
                flist = []
                for line in fobj:
                    line = line.strip()
                    if line != '':
                        flist.append(line)

        if args.port is not None:
            pars['port'] = args.port

        if not args.force:
            flist = remove_submitted(flist)

        go(flist, args)
    except KeyboardInterrupt:
        sys.exit(1)


main()
