#!/usr/bin/env python
"""
    %prog [options] module [version]

Description:
    Install the requested module.  Dependencies are also installed. 

    If version is not given, the default version is taken from the
    install configuration.

    The install configuration is assumed to be in

        $MODULESHOME/install-config/$module.install

    But this can be given using the command line input using the
    --config-url option

    Module Install Configuration:

        Install configurations are python scripts.  Variables created in these
        scripts are available to the installer.
        
        Data/variables in the installer can be referred to in the script, e.g.
        self.version

        The right combination of variables must be present in order to
        install, such as the URL, source type, and install method.

        The following is a list of variables that can be used during
        installation:

            Required values:

                url: 
                    The url to the code source.  Can be http, ftp, svn, or a
                    local file.

                source_type: 
                    The type of the source.  Currently support svn, tar,
                    tarbomb

            You must either set "build_method" and "install_method", or
            alternatively just an "install_method" that both builds
            and installs, such as "configure-make-install".

                build_method: 
                    How the code should be built.  E.g.  scons, make,
                    configure-make, cmake-make.  This is optional if
                    install_method also builds the product.

                install_method: 
                    The method of installation.  configure-make-install,
                    make-install, copy, python-setup, cmake-make-install
                
            Optional Values:

                get_method:  The method for retrieving code from the url.
                    Can be urllib, 'svn checkout', 'svn export', rsync
                    Default is urllib.

                default_version: 
                    If set, then version need not be given on the command
                    line.

                create_module_file: 
                    A string to write to the file

                        $MODULESHOME/modulefiles/product_name/version

                    This info is used by module for loading the product and
                    it's dependencies.  You can over-ride this location
                    using the --module-file location.

                build_subdir:
                    This indicates that the build should occur in a
                    subdirectory.  E.g.  if the tarball untars to a directory
                    prodname, we may have to change to the directory
                    prodname/subdir to compile.

        Example:

            This is an example install configuration for vim. Note the use
            of self.version and self.install_dir which are member variables
            in the ModuleInstaller object.

                default_version='7.2'

                url='''
                'http://ftp.vim.org/pub/vim/unix/vim-%s.tar.bz2' % self.version'''

                source_type = 'tar'

                # this will use the install_dir as prefix in configure
                install_method = 'configure-make-install'

                # create the module file after installation

                create_module_file=\"\"\"'''#%Module
                module-whatis	"The vim text editor."
                conflict vim

                prepend-path PATH %s/bin
                ''' % self.install_dir\"\"\"

            
            This is for installing numerical python. Note use of
            new style string formats, be sure your python version
            can handle it before using them.

                import os
                import distutils.sysconfig

                default_version='1.4.1'
                url='''
                'http://downloads.sourceforge.net/project/numpy/NumPy/%s/numpy-%s.tar.gz' % (self.version,self.version)'''
                source_type = 'tar'

                # this will use the install_dir as prefix in configure
                install_method = 'python-setup'
                build_command='python setup.py config_fc --fcompiler=gnu95 build'

                # create the module file after installation
                main_libdir=distutils.sysconfig.get_python_lib()
                pylib_install_subdir = main_libdir.replace(distutils.sysconfig.PREFIX+os.sep,'')
                pylib_install_subdir = pylib_install_subdir.replace('dist-packages','site-packages')


                create_module_file=\"\"\"'''#%Module
                module-whatis	"Numerical python."
                conflict numpy

                prepend-path PATH {INSTALL_DIR}/bin
                prepend-path PYTHONPATH {INSTALL_DIR}/{PYLIB_INSTALL_DIR}
                '''.format(install_dir=self.install_dir,
                           pylib_install_dir=pylib_install_subdir)\"\"\"
                    


TODO:

    * need to be more atomic: currently, there is an install failure
    but also an install of module file failure afterward, and cleanup of the
    install will not happen

    * No clobbering of existing installs or module files
    * Checking of dependencies.
"""

modification_history="""
    Created: 2009-07-26, Erin Sheldon, BNL.  Written in python.
"""

import os, sys
from sys import stdout,stderr
import shutil
import tempfile
import subprocess
import datetime
from optparse import OptionParser

try:
    import svn.core
    import svn.client
    have_svnlib=True
except:
    stdout.write('Could not import svn.  Will call via the shell\n')
    have_svnlib=False


datestring = datetime.datetime.now().strftime("%Y-%m-%d-%H:%M")

parser=OptionParser(__doc__)

parser.add_option("--config-url",dest="config_url",
                  help="Where to find an installation configuration file. "+\
                  "Default is $MODULESHOME/install-config/product.install. "+\
                  "Only file system paths currently supported.")
parser.add_option("--module-dir",
                  default=None,
                  dest="module_dir",
                  help=("Put module files under this directory as {module_name}/{version}. "
                        "default is $MODULESHOME/modulefiles"))
parser.add_option("--install-dir",
                  default=None,
                  dest="install_dir",
                  help=("Install under this directory into {install_dir}/version.  default is "
                        "$MODULE_INSTALLS/{flavor}/{module_name}. '-r' is historical."))

parser.add_option("-y","--noprompt",action="store_true",
        dest="noprompt",
        default=False,
        help="Don't prompt before installing dependencies. Default %default")

parser.add_option("--force",action="store_true",
        dest="force",
        default=False,
        help="Force use of listed install_dir even if it already "
            "exists. Useful if must install into another pacakges root, as with basemap into matplotlib.  Default %default")

config_ignores=[]
class ModuleInstaller(object):
    def __init__(self, name, 
                 version=None, 
                 module_dir=None,
                 install_config=None, 
                 nodeclare=False,
                 verbose=True, **keys):
        """
        Class:
            ModuleInstaller
        Construction:

            info can be all specified as arguments or all specified in the
            config file

            Arguments:
                name            The name of the product.  E.g. tmv

            Keywords:
                version         The version of the product, e.g. v1.5.1
                default_version The default version to use, e.g. trunk
                module_dir      The location to install module files, default
                                is ${MODULESHOME}/modulefiles/modulename/version
                install_config  A config file containing relevant installation
                                info. In the future will support remote urls.
                nodeclare       Don't declare the product.  Useful for local
                                installs.  Default False.


            Additional keywords:
                These are usually gotten from the install config.  See
                the primary docs for einstall for a description of
                the install configuarion.

                source_type     Type of source, e.g. svn, tar, tarbomb.

                get_method      Method for getting the source.  E.g. 
                                local,urllib,rsync,svn export,svn checkout.  
                                Default is urllib, which works for http, ftp, 
                                and local files.

                url             url of the source.  Can be http, svn, etc. but
                                must be understood by the get_method

                build_method    E.g. scons, make, configure-make, cmake-make
                install_method  e.g. configure-make-install, make-install,
                                copy, python-setup, cmake-make-install

                verbose         if True print lots of info. Currently
                                verbose=False is still pretty loud.

                prompt          If True, then prompt before installing 
                                dependencies.  Default True. 
        """

        self.dirstack = DirStack(verbose=True)

        self.original_dir = os.getcwd()

        self.verbose=verbose

        self.nodeclare = nodeclare

        
        self.pars={}
        self.name=name
        if self.verbose:
            stdout.write('\nModule name = %s\n' % name)

        # load a config file
        self.module_dir=module_dir
        if module_dir is None:
            self.module_dir = DefaultModuleDir()

        if install_config is None:
            install_config = DefaultInstallConfig(name) 
        if os.path.exists(install_config):
            self.LoadConfig(install_config)
        else:
            stdout.write(('\nInstall config %s not found, trying to'
                          'work from the command line '
                          'arguments\n' % install_config))

        # keywords can override options in the build file
        self.LoadKeywords(version=version, **keys)
 
        # make sure we have enough info to get/build/install
        self.ProcessPars()

        if self.verbose:
            stdout.flush()

    def DoInstall(self, prompt=None):
        if prompt is None:
            prompt=self.prompt

        self.Get()
        self.Extract()
        #self.InstallDeps(prompt=prompt)
        #self.SetupDeps()
        self.Build()
        self.Install()
        #self.Declare()
        self.Cleanup()

    
    def Get(self):
        """
        Creates the build_dir, changes into that directory, and gets the
        data.  The CWD remains the build_dir after running this program
        """

        if self.verbose:
            stdout.write('\nCreating temporary build dir...  ')
        self.build_dir=self.TempBuildDir()
        if self.verbose:
            stdout.write('%s\n' % self.build_dir)

        # from here on out everything references the build dir except for
        # the install dir
        if self.verbose:
            stdout.write('Changing CWD to build dir\n')
        self.dirstack.push(self.build_dir)

        # This actually gets the data into the CWD
        self._get()

        
    def _get(self):
        if 'svn' in self.get_method:
            if self.get_method in ['svn checkout','svn-checkout']:
                checkout=True
            elif self.get_method in ['svn export','svn-export']:
                checkout=False
            else:
                raise ValueError("Bad svn method: '%s'" % self.get_method)

            url=self.GetSVNURL()
            local_path=self.prod_dir_name

            SVNGet(url, local_path, checkout=checkout)
        elif self.get_method == 'rsync':
            url = self.GetURL()
            Rsync(url)
        elif self.get_method in ['urllib','local']:
            # Use urllib to retrieve the data
            url = self.GetURL()
            try:
                URLLibGet(url)
            except:
                URLLib2Get(url)
        else:
            raise ValueError("Unsupported get_method: '%s'" % self.get_method)


    def Extract(self):
        """
        Extract tar (.gz,.bz,..) archives.  CWD unchanged
        """
        # for archives we need to get the contents out as well
        if self.source_type.find('tar') != -1:
            url = self.GetURL()
            if os.path.exists(url):
                archive_name = os.path.basename(url)
            else:
                archive_name = GetWebBasename(url)

            if self.source_type == 'tarbomb':
                # we are already in the temp directory, make this relative and
                # untar into it
                os.mkdir(self.prod_dir_name)
                self.Untar(archive_name, outdir=self.prod_dir_name)
            elif self.source_type == 'tar':
                self.Untar(archive_name, linkto=self.prod_dir_name)
            else:
                raise ValueError('Unsupported tar type: %s' % self.source_type)
        else:
            if self.verbose:
                stdout.write('\nNo extraction required\n')
                stdout.flush()

    def Untar(self, archive_name, outdir='.', mode='r', 
              linkto=None, renameto=None):
        """
        We will loop over the members individually.  The method to do everything
        is only 2.5 or greater, and we want to be able to pick out the top
        directory, which is assumed to be the first name when the archive is not
        a tarbomb
        """
        import tarfile
        if self.verbose:
            stdout.write('\nUntarring %s\n' % archive_name)
        tf=tarfile.open(archive_name, mode)
        first=None
        for member in tf.getmembers():
            name=member.name
            if first is None:
                first=name
                if first[-1] == os.sep:
                    first=first[0:-1]

            if outdir is not '.':
                name=os.path.join(outdir, name)
            if self.verbose:
                stdout.write('%s\n' % name)
            tf.extract(member,outdir)

        if renameto is not None:
            if renameto[-1] == os.sep:
                renameto=renameto[0:-1]
            oldname=os.path.join(outdir, first)
            newname=os.path.join(outdir, renameto)
            if first != renameto:
                if self.verbose:
                    stdout.write('\nRenaming %s to %s\n' % (oldname, newname))
                os.rename(oldname, newname)
        elif linkto is not None:
            if linkto[-1] == os.sep:
                linkto=linkto[0:-1]
            oldname=os.path.join(outdir, first)
            linkname=os.path.join(outdir, linkto)
            # two checks for case-insensitive file systems
            if first != linkto and not os.path.exists(linkto):
                if self.verbose:
                    stdout.write('\nLinking %s to %s\n' % (oldname, linkname))
                os.symlink(oldname, linkname)



        if self.verbose:
            stdout.flush()

    def GetDeps(self):
        """
        Return a list of dependencies.
        """
        table_file = self.GetTableFilename()
        if table_file is None:
            return []
        
        e=eups.Eups()
        deplist = e.dependencies_from_table(table_file)
        return deplist

    def GetMissingDeps(self):
        """
        Search for the missing deps that need to be
        installed
        """
        deps = self.GetDeps()
        e=eups.Eups()
        missing_deps=[]
        for dep in deps:
            prod, optional, currentRequested = dep
            if not optional:
                try:
                    tprod = e.getProduct(prod.name, prod.version)
                except:
                    missing_deps.append(dep)

        return missing_deps

    def InstallDeps(self, prompt=True):
        """
        Recursively install dependencies
        """
        raise ValueError("make this work for modules")
        missing_deps = self.GetMissingDeps()
        if len(missing_deps) == 0:
            return

        if self.nodeclare:
            raise ValueError("You cannot set nodeclare=True when installing "
                             "dependencies, it's not supported yet.")

        if self.verbose or prompt:
            stdout.write('\nDependencies to be installed:\n')
            for dep in missing_deps:
                prod, optional, currentRequested = dep
                if currentRequested:
                    version=None
                    version_name='current'
                else:
                    version=prod.version
                    version_name=version

                stdout.write('    %s-%s\n' % (prod.name,version_name))
            stdout.flush()
            if prompt:
                response=raw_input('Continue: (y/n)? ')
                if response.lower() != 'y':
                    raise RuntimeError('Aborted install of dependencies')

        e=eups.Eups()
        for dep in missing_deps:
            prod, optional, currentRequested = dep
            if currentRequested:
                version=None
            else:
                version=prod.version

            installer = \
                    ModuleInstaller(prod.name, 
                                     version,
                                     declare_current=True)
            installer.DoInstall(prompt=False)
    
            e.declare(installer.name, 
                      installer.version, 
                      installer.install_dir, 
                      declareCurrent=True)
            e.setup(installer.name)


    def SetupDeps(self):
        """
        Make sure deps are set up in case needed for
        compilation
        """
        raise ValueError("make this work for modules")
        deps = self.GetDeps()
        e=eups.Eups()
        for dep in deps:
            prod, optional, currentRequested = dep
            e.setup(prod.name, prod.version)



    def GetTableFilename(self):
        """

        If the create_ups statement is present in the install file then it's
        contents are used to make a temporary file.  Otherwise a table file is
        searched for a ups subdirectory

        Assumes the CWD is the build_dir for cleaning up temporary
        files
        """
        
        if 'create_module_file' in self.pars:
            # create the ups table with the given string
            text=self.TryEval(self.pars['create_module_file'])

            tmpdir = tempfile.mkdtemp(dir='.', prefix='scratchdir-')
            table_file = os.path.join(tmpdir, self.name+'.table')
            if self.verbose:
                stdout.write('\nCreating temporary module file for getting deps: %s\n' % table_file)
                stdout.flush()
            fobj=open(table_file,'w')
            fobj.write(text)
            fobj.close()
        else:
            # look for the ups subdirectory
            # should we add other possibilities?
            subdir = os.path.join(self.prod_dir_name, 'ups')
            if not os.path.exists(subdir):
                if self.verbose:
                    stdout.write('ups directory not found, assuming no dependencies]n')
                return None
            else:
                table_file = os.path.join(subdir, self.name+'.table')
                if not os.path.exists(table_file):
                    if self.verbose:
                        stdout.write('table file not found, assuming no dependencies]n')
                    return None
                else:
                    return os.path.abspath(table_file)
        return table_file

    def get_build_subdir(self):
        build_subdir = self.prod_dir_name
        if 'build_subdir' in self.pars:
            build_subdir = os.path.join(build_subdir, self.pars['build_subdir'])
        return build_subdir

    def Build(self):
        """
        This program cds into the subdirectory containing the data,
        builds the program, and then returns to the build_dir
        """

        if 'build_method' not in self.pars:
            if self.verbose:
                stdout.write('\nNo build_method found; doing a '+\
                             'straight install\n')
                stdout.flush()
                return

        if self.verbose:
            stdout.write('\nBuilding product\n')

        build_subdir = self.get_build_subdir()
        stdout.write("moving to build_subdir: %s\n" % build_subdir)
        self.dirstack.push(build_subdir)

        build_method = self.pars['build_method']
        if build_method == 'scons':
            self.RunScons()
        elif build_method == 'configure-make':
            self.RunMake(configure=True)
        elif build_method == 'make':
            self.RunMake()
        elif build_method == 'cmake-make':
            self.RunCMake()
        else:
            raise ValueError("Unsupported build_method '%s'" % build_method)
        self.dirstack.pop()

    def Install(self):
        """
        This program changes into the subdirectory containing the data,
        installs the program, and then returns to the build_dir
        """

        # for now just throw an exception.  We could make a command line
        # option to remove  the existing directory
        if os.path.exists(self.install_dir) and not self.pars['force']:
            raise RuntimeError("install dir %s already "
                               "exists" % self.install_dir)


        build_subdir = self.get_build_subdir()
        stdout.write("moving to build_subdir: %s\n" % build_subdir)
        self.dirstack.push(build_subdir)

        if 'install_command' in self.pars:
            install_command = eval(self.pars['install_command'])
            stdout.write("Executing install command: %s\n" % install_command)
            ExecuteCommand(install_command)
        elif self.install_method == 'copy':
            self.CopyInstall()
        elif self.install_method == 'scons':
            self.RunScons(install=True)
        elif self.install_method == 'configure-make-install':
            self.RunMake(configure=True, install=True)
        elif self.install_method == 'make-install':
            self.RunMake(install=True)
        elif self.install_method == 'cmake-make-install':
            self.RunCMake(install=True)
        elif self.install_method == 'python-setup':
            self.RunPythonSetup()
        else:
            raise ValueError('Unsupported install method %s' % self.install_method)

        self.PostInstall()

        self.dirstack.pop()

        if 'create_module_file' in self.pars:
            # create the module file with the given string
            module_dir = os.path.join(self.module_dir, self.name)

            if not os.path.exists(module_dir):
                stdout.write("\nCreating module dir: %s\n" % module_dir)
                os.mkdir(module_dir)

            module_file = os.path.join(module_dir, self.version)

            if self.verbose:
                stdout.write('\nCreating module file: %s\n' % module_file)
                stdout.flush()

            stdout.write(self.pars['create_module_file'])
            text=self.TryEval(self.pars['create_module_file'])

            fobj=open(module_file,'w')
            fobj.write(text)
            fobj.close()


    def CopyInstall(self):

        if self.verbose:
            stdout.write('\nCreating install directory: %s\n' % \
                         self.install_dir)
        # we need to make the directories up to the last bit since 
        # shutil.copytree doesn't want the last piece
        install_dir_base = os.path.dirname(self.install_dir)
        if not os.path.exists(install_dir_base):
            os.makedirs(install_dir_base)

        if self.verbose:
            stdout.write('\nCopying from %s to %s/\n' % \
                (os.path.abspath('.'),os.path.abspath(self.install_dir)))
            stdout.flush()
        shutil.copytree('.',self.install_dir)


    def PostInstall(self):
        if 'post_install' in self.pars:
            eval(self.pars['post_install'])

    def Declare(self):
        if self.nodeclare:
            stdout.write("\nNot declaring product at user request.\n")
            return

        e=eups.Eups()
        if self.verbose:
            if self.declare_current:
                dc="as current"
            else:
                dc=""
            mess="\nDeclaring product %s %s %s in install_dir %s\n" % \
                    (self.name, self.version, dc, self.install_dir)
            stdout.write(mess)
        e.declare(self.name, self.version, self.install_dir, 
                  declareCurrent=self.declare_current)

    def Cleanup(self):
        if self.verbose:
            stdout.write('\nCleaning up build_dir: %s\n' % self.build_dir)
        shutil.rmtree(self.build_dir)
        # we should already be here if we remembered to pop() the dir
        # but this is just in case
        os.chdir(self.original_dir)




    def DefaultInstallDir(self):
        flavor_dir=FlavorDir()
        install_dir=os.path.join(flavor_dir, self.name, self.version)
        return install_dir



    def RunScons(self, install=False):
        command = 'scons'
        if 'build_flags' in self.pars:
            command += ' '+self.pars['build_flags']
        if install:
            command += ' install PREFIX='+self.install_dir
        ExecuteCommand(command)


    def RunMake(self, configure=False, install=False):
        command = ['make']
        if configure:
            ccommand = './configure --prefix='+self.install_dir
            if 'config_flags' in self.pars:
                ccommand += ' '+self.pars['config_flags']
            command = [ccommand]+command
        if install:
            # Some Makefiles we use take this environment variable rather
            # than doing ./configure --prefix
            os.putenv('INSTALL_DIR',self.install_dir)
            # cover all the bases: put PREFIX= also
            command += ['make install PREFIX='+self.install_dir]
        command = ' && '.join(command)
        ExecuteCommand(command)

    def RunCMake(self, install=False):
        command = 'cmake -DCMAKE_INSTALL_PREFIX='+self.install_dir
        if 'config_flags' in self.pars:
            command += ' '+self.pars['config_flags']
        command = [command,'make']

        if install:
            # Some Makefiles we use take this environment variable rather
            # than doing ./configure --prefix
            os.putenv('INSTALL_DIR',self.install_dir)
            command += ['make install']
        command = ' && '.join(command)
        ExecuteCommand(command)




    def RunPythonSetup(self):
        # First build
        if 'build_command' in self.pars:
            command=self.pars['build_command']
        else:
            command = 'python setup.py build'
            if 'build_args' in self.pars:
                command += ' '+self.pars['build_args']
        ExecuteCommand(command)

        # now run the install
        if 'install_command' in self.pars:
            command = self.pars['install_command']
        else:
            command = 'python setup.py install'
            if 'install_args' in self.pars:
                command += ' '+self.pars['install_args']

        command += ' --prefix='+self.install_dir
        ExecuteCommand(command)

    def GetSVNURL(self):
        if not 'base_url' in self.pars:
            raise ValueError('You must set base_url for svn exports')
        if self.version == 'trunk':
            # note this is a network address and requires /
            url = self.pars['base_url'] + '/trunk'
        else:
            url = self.pars['base_url'] + '/tags/'+self.version
        return url

    def GetURL(self):
        if 'url' in self.pars:
            url = self.TryEval(self.pars['url'])
        else:
            raise ValueError("For this method you must give a url "
                             "expression in the install file or command line")
        return url

    def TempBuildDir(self):
        # Create a temporary directory in the CWD for building
        # the install.  We will have to delete it.
        prefix=self.name+'-'+self.version+'-'
        tmpdir=tempfile.mkdtemp(prefix=prefix, dir='.',suffix='-modulebuild')
        tmpdir = os.path.abspath(tmpdir)
        return tmpdir

    def ProcessPars(self):
        """
        Process the input pars 
        """

        # figure out what version we are dealing with
        if 'version' not in self.pars:
            if 'default_version' not in self.pars:
                raise ValueError("If no version is specified explicitly "
                                 "then a default_version must be specified")
            self.pars['version'] = self.pars['default_version']

        self.version = self.pars['version']
            
        # This is the name of the subdirectory that will contain the data
        self.prod_dir_name=self.name+'-'+self.version

        # prompt for dependencies?
        if 'prompt' in self.pars:
            self.prompt=self.pars['prompt']
        else:
            self.prompt=True

        # figure out how to get it
        if 'source_type' in self.pars:
            self.source_type=self.pars['source_type']
        else:
            raise ValueError('You must specify a source type')
        if 'get_method' in self.pars:
            self.get_method=self.pars['get_method']
        else:
            # default to looking for a local file or using urllib
            self.get_method = 'urllib'
        
        if 'install_method' in self.pars:
            self.install_method = self.pars['install_method']
        else:
            self.install_method = 'copy'

        self.install_dir = self.pars.get('install_dir',None)
        if self.install_dir is None:
            self.install_dir = self.DefaultInstallDir()
        else:
            self.install_dir = os.path.abspath(self.install_dir)

        if 'declare_current' in self.pars:
            self.declare_current = self.pars['declare_current']
        else:
            self.declare_current = False

    def TryEval(self,expression):
        """
        Try to evaluate an expression that may use internal or global 
        variables. e.g
            'http://some.base.url/some-name-%s.tar.gz' % (self.version)
        if the eval fails, the string itself is returned
        """
        try:
            val=eval(expression)
        except:
            val=expression
        return val

    def LoadKeywords(self, version=None, **keys):
        if self.verbose:
            stdout.write('\nChecking command line keywords\n')


        if version is not None:
            self.pars['version'] = version

        for k in keys:
            self.pars[k] = keys[k]
            if self.verbose:
                stdout.write('    %s = %s\n' % (k,self.pars[k]))



    def LoadConfig(self,filename):
        """
        Load the python config file using an exec() statement.
        """

        glob={}
        loc={}

        exec(open(filename),glob,loc)

        if self.verbose:
            stdout.write('\nLoading install config: %s\n' % filename)
        for key in loc:
            if loc[key] not in config_ignores:
                self.pars[key] = loc[key]
                if self.verbose:
                    stdout.write('    %s = %s\n' % (key,self.pars[key]))



# copied from esutil.ostools
class DirStack(object):
    """
    Class:
        DirStack
    Purpose:
        A simple directory stack.

    Construction:
        ds=DirStack(verbose=False):  If verbose=True a message is
            printed for push and pop similar to that printed on 
            unix systems.
    Methods:
        push(directory): Change to the input directory.  Push the
            current working directory onto the stack.
        pop: Pop the last directory from the stack and change to
            that directory.

    Example:
        >>> ds=DirStack(verbose=True)
        >>> ds.push('~/data')
        ~/data ~
        >>> ds.push('/usr/bin')
        /usr/bin ~/data ~
        >>> ds.pop()
        ~/data ~
        >>> ds.pop()
        ~

    """
    def __init__(self, verbose=False):
        self.verbose=verbose
        self._home = os.path.expanduser('~')
        self._dirs = []

    def push(self, dir):
        """
        push(dir):  Change to the indicated dir and push the current
            working directory onto the stack
        """
        dir=os.path.expandvars(dir)
        dir=os.path.expanduser(dir)

        old_dir = os.getcwd()

        os.chdir(dir)
        
        # only do this *after* we successfully chdir
        self._dirs.append(old_dir)
        if self.verbose:
            self.print_stack()


    def pop(self):
        """
        pop(): Pop the last directory from the stack and change to
            that directory.
        """
        if len(self._dirs) == 0:
            stdout.write("Directory stack is empty\n")
            return

        dir = self._dirs.pop()
        os.chdir(dir)

        if self.verbose:
            self.print_stack()

    def getstack(self):
        """
        getstack(): Return the current stack.
        """
        return self._dirs

    def print_stack(self):
        self.print_dir(os.getcwd())
        for i in xrange(len(self._dirs)-1,-1,-1):
            d=self._dirs[i]
            self.print_dir(d)
        stdout.write('\n')
    def print_dir(self, dir):
        dir = dir.replace(self._home, '~')
        stdout.write('%s ' % dir)



def ExecuteCommand(command, get_output=False, verbose=True):
    if verbose:
        stdout.write('\nExecuting: %s\n' % command)
        stdout.flush()
    if get_output:
        retcode=subprocess.Popen(command, shell=True,
                                 stdout=subprocess.PIPE, 
                                 stderr=subprocess.PIPE)
        if pobj.returncode != 0:
            raise RuntimeError('%s failed' % command)
        (stdout_data, stderr_data) = pobj.communicate()
        return stdout_data, stderr_data
        
    else:
        # stdout/stderr will go to the screen
        retcode=subprocess.call(command, shell=True)
        if retcode != 0:
            raise RuntimeError('%s failed' % command)
        return None

def URLLibGet(url):
    """
    use urllib to download the source into CWD
    """
    import urllib

    if os.path.exists(url):
        # It's a local file
        dest = os.path.basename(url)
    else:
        # Its a web/ftp address
        dest = GetWebBasename(url)

    stdout.write("\nCopying from '%s' to '%s'\n" % (url, dest))
    urllib.urlretrieve(url, dest)

    stdout.flush()

def URLLib2Get(url):
    """
    use urllib2 to download the source into CWD

    not actually using this yet
    """
    import urllib2

    if os.path.exists(url):
        # It's a local file
        dest = os.path.basename(url)
    else:
        # Its a web/ftp address
        dest = GetWebBasename(url)

    stdout.write("\nCopying from '%s' to '%s'\n" % (url, dest))
    #urllib2.urlretrieve(url, dest)

    try:
        req = urllib2.Request(url)
        f = urllib2.urlopen(req)
        local_file = open(dest, 'w')
        local_file.write( f.read() )
        local_file.close()
    except urllib2.URLError:
        stdout.write('Failed to get url')
        stdout.write('trying with proxy\n')
        URLLib2GetWithProxy(url)

    stdout.flush()


def URLLib2GetWithProxy(url):
    """
    use urllib2 to download the source into CWD with a proxy

    not actually using this yet
    """

    import urllib2
    
    #req = urllib2.Request(url)
    opener = urllib2.build_opener(urllib2.ProxyBasicAuthHandler)

    #f = opener.open(req)
    f = opener.open(url)
    local_file = open(dest, 'w')
    local_file.write( f.read() )
    local_file.close()

    stdout.flush()



def Rsync(source, dest='.'):
    """
    rsync -av source into dest
    """
    command = 'rsync -av %s %s' % (source, dest)
    ExecuteCommand(command)

def SVNGet(url_in, local_path, checkout=False, verbose=True):

    try:
        import svn.core
        import svn.client
        #if have_svnlib:
        # We have the bindings to the svn C library
        url=url_in
        if url[-1] == '/':
            # the c library chokes on the ending / when exporting
            url=url[0:-1]

        # This is all setup for the checkout/export
        pool = svn.core.svn_pool_create(None)

        svn.core.svn_config_ensure( None, pool )

        ctx = svn.client.svn_client_ctx_t()

        config = svn.core.svn_config_get_config( None, pool )
        ctx.config = config

        rev = svn.core.svn_opt_revision_t()
        rev.kind = svn.core.svn_opt_revision_head
        rev.number = 0

        ctx.auth_baton = svn.core.svn_auth_open( [], pool )

        recurse=True

        if checkout:
            gettype='checkout'
            if verbose:
                stdout.write('\nsvn checkout %s %s\n' % (url, local_path) )
            revision=svn.client.svn_client_checkout(url, local_path, 
                                                    rev, recurse, 
                                                    ctx, pool)
        else:
            gettype='export'
            if verbose:
                stdout.write('\nsvn export %s %s\n' % (url, local_path) )
            revision = svn.client.svn_client_export(url, local_path, 
                                                    rev, recurse, 
                                                    ctx, pool)

        if revision == -1:
            raise RuntimeError('Failed to %s url %s' % (gettype, url))

        if verbose:
            stdout.write('At revision %s\n' % revision)
            stdout.flush()
        svn.core.svn_pool_destroy(pool)

    except:
        # no bindings to the C library or a problem with authentication.  
        # Try spawning the command.  this is less platform independent.
        if checkout:
            svn_comm='checkout'
        else:
            svn_comm='export'
        command='svn %s %s %s' % (svn_comm, url_in, local_path)
        ExecuteCommand(command)


def GetWebBasename(url):
    # separator on the web is /
    urlsplit=url.split('/')
    if urlsplit[-1] != '':
        name=urlsplit[-1]
    else:
        name=urlsplit[-2]
    return name




def GetEnv(name):
    if not os.environ.has_key(name):
        raise ValueError('%s is not set' % name)
    return os.getenv(name)

def Flavor():
    """Return the current flavor"""
    import re
    uname = os.uname()[0]
    mach =  os.uname()[4]

    if uname == "Linux":
       if re.search(r"_64$", mach):
           flav = "Linux64"
       else:
           flav = "Linux"
    elif uname == "Darwin":
       if re.search(r"i386$", mach):
           flav = "DarwinX86"
       else:
           flav = "Darwin"
    else:
        raise RuntimeError, ("Unknown flavor: (%s, %s)" % (uname, mach))

    return flav    


def FlavorDir():
    def_install_base = GetEnv('MODULE_INSTALLS')
    flavor=Flavor()
    return os.path.join(def_install_base, flavor)

def InstallConfigDir():
    path=GetEnv('MODULESHOME')
    return os.path.join(path,'install-config')

def DefaultInstallConfig(name):
    return os.path.join(InstallConfigDir(), name+'.install')

def DefaultModuleDir():
    path=GetEnv('MODULESHOME')
    path=os.path.join(path, 'modulefiles')
    return path










if __name__=="__main__":
    options, args = parser.parse_args(sys.argv[1:])
    nargs=len(args)
    if nargs < 1:
        parser.print_help()
        sys.exit(45)

    product=args[0]
    if nargs > 1:
        version=args[1]
    else:
        version=None

    if options.noprompt:
        prompt=False
    else:
        prompt=True

    force=options.force

    prod=ModuleInstaller(product, version, 
                         prompt=prompt,
                         module_dir=options.module_dir,
                         install_config=options.config_url,
                         #nodeclare=options.nodeclare,
                         #declare_current=options.declare_current, 
                         install_dir=options.install_dir, 
                         force=force) 
    prod.DoInstall()

